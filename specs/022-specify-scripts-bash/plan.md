# Implementation Plan: 年化收益門檻套利機會偵測

**Branch**: `022-annualized-return-threshold` | **Date**: 2025-11-22 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/022-specify-scripts-bash/spec.md`

**Note**: This template is filled in by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

將套利機會偵測邏輯從固定利差門檻 (≥0.5%) 改為基於年化收益的門檻 (預設 ≥800%)，確保跨時間基準（1h/4h/8h/24h）判定結果一致。

**Primary Issue**: 當前固定利差門檻在不同時間基準下會產生不一致的判定結果，導致用戶困惑。

**Technical Approach**:
1. 修改後端 `RateDifferenceCalculator.ts` 使用年化收益判斷
2. 修改 `RatesCache.ts` 統計計算邏輯
3. 修改前端 `rateCalculations.ts` 狀態判定邏輯
4. 支援環境變數 `OPPORTUNITY_THRESHOLD_ANNUALIZED` 配置門檻
5. 新增/更新單元測試

## Technical Context

**Language/Version**: TypeScript 5.6 + Node.js 20.x LTS
**Primary Dependencies**:
- Next.js 14 App Router (前端)
- Socket.io 4.8.1 (WebSocket 通訊)
- Vitest (測試框架)

**Storage**: N/A（不涉及資料庫變更，僅修改記憶體中的計算邏輯）

**Testing**:
- Vitest (單元測試)
- 手動測試 (前端時間基準切換驗證)

**Target Platform**:
- 後端：Node.js 服務器（CLI 監控服務）
- 前端：Next.js Web 應用（瀏覽器）

**Project Type**: Web application（前後端分離架構）

**Performance Goals**:
- 前端時間基準切換後，重新計算完成時間 < 100ms（200 個交易對）
- 不影響現有的即時數據推送性能

**Constraints**:
- 不可修改資料庫 schema
- 必須保持前後端計算邏輯一致
- 必須向後兼容現有的 API 數據結構
- 環境變數未設定時使用預設值 800%

**Scale/Scope**:
- 影響範圍：3 個核心文件的計算邏輯修正
- 測試覆蓋：4 個時間基準（1h, 4h, 8h, 24h）
- 用戶影響：所有使用市場監控功能的用戶

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Compliance Review

✅ **I. Trading Safety First (NON-NEGOTIABLE)**
- **Status**: Not applicable
- **Rationale**: 此修正不涉及交易執行邏輯，僅修正顯示和偵測邏輯。不影響交易安全。

✅ **II. Complete Observability (NON-NEGOTIABLE)**
- **Status**: Compliant
- **Actions**:
  - 無效環境變數值時記錄警告日誌
  - 保持現有的結構化日誌（Pino）
- **No violations**

✅ **III. Defensive Programming**
- **Status**: Compliant
- **Actions**:
  - 環境變數驗證：無效值回退使用預設值 800%
  - 邊界條件處理：門檻值為 0 或極高值時正確處理
- **No violations**

✅ **IV. Data Integrity**
- **Status**: Compliant
- **Rationale**:
  - 不涉及資料庫 schema 變更
  - 僅修正計算邏輯，不影響數據存儲
- **No violations**

✅ **V. Incremental Delivery**
- **Status**: Compliant
- **Plan**:
  1. 先修正後端計算邏輯並添加測試
  2. 同步修正前端計算邏輯
  3. 在所有時間基準下驗證測試
  4. 部署前在測試環境驗證
- **No violations**

✅ **VI. System Architecture Boundaries**
- **Status**: Compliant
- **Rationale**:
  - CLI 負責計算（RateDifferenceCalculator, RatesCache）
  - Web 負責顯示（rateCalculations.ts 在前端重新計算）
  - 數據流保持不變：CLI → RatesCache → Web API → Web UI
  - 不改變架構邊界
- **No violations**

### Gate Decision

✅ **PASS** - No constitution violations. Proceed to implementation.

## Project Structure

### Documentation (this feature)

```
specs/022-specify-scripts-bash/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # ❌ Not needed - solution is straightforward
├── data-model.md        # ❌ Not needed - no schema changes
├── quickstart.md        # ❌ Not needed - no new setup required
├── contracts/           # ❌ Not needed - no API changes
├── checklists/
│   └── requirements.md  # Specification quality checklist
└── tasks.md             # Generated by /speckit.tasks (next step)
```

**Rationale for skipped artifacts**:
- **research.md**: 解決方案明確（年化收益 = spread × 365 × (24/timeBasis) × 100）
- **data-model.md**: 不涉及資料庫模型變更
- **quickstart.md**: 無需新的設置步驟
- **contracts/**: 不涉及 API 合約變更

### Source Code (repository root)

```
# Affected files (修正範圍)
src/
├── services/
│   └── monitor/
│       ├── RateDifferenceCalculator.ts  # 修改 isArbitrageOpportunity 方法
│       └── RatesCache.ts                # 修改統計計算邏輯
└── lib/
    └── config.ts                        # 新增門檻值配置（可選）

app/(dashboard)/market-monitor/
└── utils/
    └── rateCalculations.ts              # 修改狀態判定邏輯

# Test files (to be created/updated)
tests/
└── unit/
    ├── services/
    │   └── RateDifferenceCalculator.test.ts  # 年化收益門檻測試
    └── frontend/
        └── rateCalculations.test.ts          # 前端計算邏輯測試（已存在）
```

**Structure Decision**: 使用現有的專案結構。此功能修正不需要新增目錄或重組結構，僅修改現有文件中的計算邏輯。

## Implementation Strategy

### Phase 1: 後端修正

#### 1.1 修改 RateDifferenceCalculator.ts

**Current Logic**:
```typescript
// 固定利差門檻
const isOpportunity = spread >= 0.005; // 0.5%
```

**New Logic**:
```typescript
// 年化收益門檻（從環境變數讀取，預設 800%）
const threshold = parseFloat(process.env.OPPORTUNITY_THRESHOLD_ANNUALIZED || '800');
const annualizedReturn = spread * 365 * (24 / timeBasis) * 100;
const isOpportunity = annualizedReturn >= threshold;
```

#### 1.2 修改 RatesCache.ts 統計計算

**Current Logic**:
```typescript
// getStats() 方法
opportunityCount: spread >= 0.5%
approachingCount: spread >= 0.4% && < 0.5%
```

**New Logic**:
```typescript
// getStats() 方法
const threshold = 800; // 或從配置讀取
const approachingThreshold = threshold * 0.75; // 600%
opportunityCount: annualizedReturn >= threshold
approachingCount: annualizedReturn >= approachingThreshold && < threshold
```

### Phase 2: 前端修正

#### 2.1 修改 rateCalculations.ts

同步後端邏輯，確保前端狀態判定與後端一致。

**Current Logic**:
```typescript
if (spreadPercent >= 0.5) {
  status = 'opportunity';
} else if (spreadPercent >= 0.4) {
  status = 'approaching';
}
```

**New Logic**:
```typescript
const OPPORTUNITY_THRESHOLD = 800; // 年化 800%
const APPROACHING_THRESHOLD = 600; // 年化 600%

if (annualizedReturn >= OPPORTUNITY_THRESHOLD) {
  status = 'opportunity';
} else if (annualizedReturn >= APPROACHING_THRESHOLD) {
  status = 'approaching';
}
```

### Phase 3: 測試

#### 3.1 單元測試

```typescript
describe('Annualized Return Threshold', () => {
  test('should identify opportunity when annualized return >= 800%', () => {
    // 測試 1h, 4h, 8h, 24h 時間基準下的一致性
  });

  test('should identify approaching when 600% <= annualized < 800%', () => {
    // 測試接近機會的判定
  });

  test('should use default threshold when env var not set', () => {
    // 測試預設值
  });

  test('should fallback to default when env var is invalid', () => {
    // 測試無效環境變數
  });
});
```

## Complexity Tracking

**No complexity violations** - This is a straightforward logic modification within existing architecture.

All changes are confined to calculation logic in existing files. No new patterns, abstractions, or architectural changes introduced.

## Next Steps

1. ✅ Complete plan.md (this file)
2. ⏭️ Run `/speckit.tasks` to generate detailed task breakdown
3. ⏭️ Run `/speckit.implement` to execute implementation
4. ⏭️ Run tests and verify fixes
5. ⏭️ Merge to main and deploy
