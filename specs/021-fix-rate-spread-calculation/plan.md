# Implementation Plan: 修正費率差異計算的時間基準一致性

**Branch**: `021-fix-rate-spread-calculation` | **Date**: 2025-01-21 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/021-fix-rate-spread-calculation/spec.md`

**Note**: This template is filled in by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

修正市場監控中費率差異和年化報酬的計算邏輯，確保當用戶切換時間基準時，費率差異能夠正確地根據選擇的時間基準動態變動，同時年化報酬計算保持一致。

**Primary Issue**: 後端年化收益計算使用固定的 8 小時週期（`spread * 365 * 3 * 100`），導致與前端動態計算不一致。

**Technical Approach**:
1. 修改後端 `src/models/FundingRate.ts` 中的年化收益公式，使用動態時間基準參數
2. 增強 `getNormalizedRate` 函數的健壯性，處理標準化數據缺失的情況
3. 添加單元測試和集成測試驗證修正邏輯
4. 在所有時間基準下測試驗證計算正確性

## Technical Context

**Language/Version**: TypeScript 5.6 + Node.js 20.x LTS
**Primary Dependencies**:
- Prisma 5.x (ORM - 用於數據模型定義，本次不涉及 schema 變更)
- Socket.io 4.8.1 (WebSocket 通訊 - 用於推送即時費率數據)
- Next.js 14 App Router (Web 框架 - 前端顯示)

**Storage**: PostgreSQL 15 + TimescaleDB（現有資料庫，本次修復不涉及 schema 變更）

**Testing**:
- Jest (單元測試 - 測試計算邏輯)
- Integration tests (集成測試 - 測試完整數據流)

**Target Platform**:
- 後端：Node.js 服務器（CLI 監控服務）
- 前端：Next.js Web 應用（瀏覽器）

**Project Type**: Web application（前後端分離架構）

**Performance Goals**:
- 費率差異計算在切換時間基準時應在 100 毫秒內完成
- 不影響現有的即時數據推送性能（維持 ~50ms WebSocket 延遲）

**Constraints**:
- 不可修改資料庫 schema
- 不可影響現有的標準化費率計算邏輯
- 必須保持前後端計算邏輯一致
- 必須向後兼容現有的 API 數據結構

**Scale/Scope**:
- 影響範圍：2 個核心文件的計算邏輯修正
- 測試覆蓋：4 個時間基準（1h, 4h, 8h, 24h）
- 用戶影響：所有使用市場監控功能的用戶

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Compliance Review

✅ **I. Trading Safety First (NON-NEGOTIABLE)**
- **Status**: Not applicable
- **Rationale**: 此修正不涉及交易執行邏輯，僅修正顯示計算。不影響交易安全。

✅ **II. Complete Observability (NON-NEGOTIABLE)**
- **Status**: Compliant
- **Actions**:
  - 在 `getNormalizedRate` 函數中添加警告日誌，記錄標準化數據缺失的情況
  - 保持現有的結構化日誌（Pino）
- **No violations**

✅ **III. Defensive Programming**
- **Status**: Compliant
- **Actions**:
  - 增強 `getNormalizedRate` 函數處理標準化數據缺失的情況
  - 添加降級邏輯：標準化數據缺失時進行即時計算
  - 添加參數驗證：確保 timeBasis 為有效值（1, 4, 8, 24）
- **No violations**

✅ **IV. Data Integrity**
- **Status**: Compliant
- **Rationale**:
  - 不涉及資料庫 schema 變更
  - 僅修正計算邏輯，不影響數據存儲
  - 使用現有的 Decimal 類型處理財務計算
- **No violations**

✅ **V. Incremental Delivery**
- **Status**: Compliant
- **Plan**:
  1. 先修正後端計算邏輯並添加測試
  2. 增強前端計算邏輯（如需要）
  3. 在所有時間基準下驗證測試
  4. 部署前在測試環境驗證
- **No violations**

✅ **VI. System Architecture Boundaries**
- **Status**: Compliant
- **Rationale**:
  - CLI 負責計算並寫入資料庫（修正後端計算邏輯）
  - Web 負責顯示（使用前端重新計算邏輯，已存在）
  - 數據流：CLI → Database → Web API → Web UI（保持不變）
  - 不改變架構邊界
- **No violations**

### Gate Decision

✅ **PASS** - No constitution violations. Proceed to implementation.

## Project Structure

### Documentation (this feature)

```
specs/021-fix-rate-spread-calculation/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # ❌ Not needed - bug fix with clear solution
├── data-model.md        # ❌ Not needed - no schema changes
├── quickstart.md        # ❌ Not needed - bug fix, no new setup
├── contracts/           # ❌ Not needed - no API changes
├── checklists/
│   └── requirements.md  # Specification quality checklist
└── tasks.md             # Generated by /speckit.tasks (next step)
```

**Rationale for skipped artifacts**:
- **research.md**: Problem root cause and solution are already identified in spec.md
- **data-model.md**: No database schema changes required
- **quickstart.md**: Bug fix doesn't require new setup instructions
- **contracts/**: No API contract changes, using existing data structures

### Source Code (repository root)

```
# Affected files (bug fix scope)
src/
├── models/
│   └── FundingRate.ts               # 修正年化收益計算公式 (line 270)
│                                     # 增強 getNormalizedRate 邏輯 (line 131-146)
└── lib/
    └── fundingRateUtils.ts          # 可能需要添加輔助函數（如需要）

app/(dashboard)/market-monitor/
├── utils/
│   └── rateCalculations.ts          # 同步前端 getNormalizedRate 邏輯 (line 23-41)
│                                     # 可能添加調試日誌（開發階段）
└── types.ts                          # 確認型別定義（不需修改）

# Test files (to be created/updated)
tests/
├── unit/
│   ├── models/
│   │   └── FundingRate.test.ts      # 測試後端計算邏輯
│   └── services/
│       └── FundingRateValidator.test.ts  # 可能需要更新
└── integration/
    └── rate-calculation.test.ts     # 端到端計算邏輯測試
```

**Structure Decision**: 使用現有的單一專案結構（src/ + tests/）。此 bug 修復不需要新增目錄或重組結構，僅修改現有文件中的計算邏輯。

## Implementation Strategy

### Phase 0: Problem Analysis ✅ (Already Complete)

**Status**: Analysis completed during investigation phase

**Key Findings**:
1. **Root Cause**: `src/models/FundingRate.ts:270` 使用固定公式 `spread * 365 * 3 * 100`
2. **Impact**: 導致年化報酬計算與時間基準不一致
3. **Solution**: 改為動態公式 `spread * 365 * (24 / timeBasis) * 100`

**No research.md needed** - solution is straightforward.

### Phase 1: Code Modification Plan

#### 1.1 後端修正 (`src/models/FundingRate.ts`)

**File**: `src/models/FundingRate.ts`

**Change 1: 修正年化收益計算（line 270）**

**Current**:
```typescript
spreadAnnualized: spread * 365 * 3 * 100,
```

**Fixed**:
```typescript
spreadAnnualized: spread * 365 * (24 / timeBasis) * 100,
```

**Change 2: 增強 getNormalizedRate 函數（line 131-146）**

**Enhanced logic**:
```typescript
function getNormalizedRate(
  exchangeData: ExchangeRateData,
  timeBasis: TimeBasis
): number {
  const timeBasisKey = `${timeBasis}h` as '1h' | '4h' | '8h' | '24h';
  const normalized = exchangeData.normalized?.[timeBasisKey];
  const originalInterval = exchangeData.originalFundingInterval;

  // 規則 1: 優先使用標準化值（如果存在且需要標準化）
  if (
    normalized !== undefined &&
    normalized !== null &&
    originalInterval &&
    originalInterval !== timeBasis
  ) {
    return normalized;
  }

  // 規則 2: 如果原始週期等於目標時間基準，直接使用原始費率
  if (originalInterval === timeBasis) {
    return exchangeData.rate.fundingRate;
  }

  // 規則 3: 降級處理 - 即時計算標準化值
  if (originalInterval && originalInterval !== timeBasis) {
    const originalRate = exchangeData.rate.fundingRate;
    // 標準化公式：rate_new = rate_original * (interval_target / interval_original)
    return originalRate * (timeBasis / originalInterval);
  }

  // 規則 4: 最後降級 - 返回原始費率並記錄警告
  logger.warn({
    msg: 'Missing normalization data, using original rate',
    timeBasis,
    originalInterval,
    exchangeName: exchangeData.exchange,
  });
  return exchangeData.rate.fundingRate;
}
```

#### 1.2 前端同步修正 (`app/(dashboard)/market-monitor/utils/rateCalculations.ts`)

**File**: `app/(dashboard)/market-monitor/utils/rateCalculations.ts`

**Change: 同步 getNormalizedRate 邏輯（line 23-41）**

應用與後端相同的增強邏輯，確保前後端計算一致。

#### 1.3 測試計劃

**Unit Tests** (`tests/unit/models/FundingRate.test.ts`):
```typescript
describe('FundingRate - Annualized Return Calculation', () => {
  test('should calculate annualized return with 1h timeBasis', () => {
    // spread = 0.000751, timeBasis = 1
    // expected = 0.000751 * 365 * 24 * 100 = 658.176
  });

  test('should calculate annualized return with 8h timeBasis', () => {
    // spread = 0.006008, timeBasis = 8
    // expected = 0.006008 * 365 * 3 * 100 = 657.876
  });

  test('annualized return should be consistent across timeBasis', () => {
    // Verify: annual_1h ≈ annual_4h ≈ annual_8h ≈ annual_24h
  });
});

describe('getNormalizedRate', () => {
  test('should return normalized value when available and different from timeBasis', () => {
    // Test normalizedRate selection logic
  });

  test('should return original rate when originalInterval equals timeBasis', () => {
    // Test direct return logic
  });

  test('should calculate on-the-fly when normalized data missing', () => {
    // Test fallback calculation
  });

  test('should log warning when all normalization fails', () => {
    // Test最後降級邏輯
  });
});
```

**Integration Tests** (`tests/integration/rate-calculation.test.ts`):
```typescript
describe('Rate Calculation Integration', () => {
  test('should calculate correct spread and annualized return for all timeBasis', () => {
    // Test complete flow: WebSocket data → calculation → display
  });

  test('spread should scale proportionally with timeBasis', () => {
    // Verify: spread_8h = spread_1h * 8
  });
});
```

#### 1.4 部署驗證計劃

**Pre-deployment**:
1. 所有單元測試通過
2. 所有集成測試通過
3. 手動驗證：在本地環境切換所有時間基準，檢查數值正確性

**Post-deployment**:
1. 監控 WebSocket 推送的費率數據
2. 驗證前端顯示的費率差異和年化報酬
3. 檢查日誌中是否有異常警告

### Phase 2: Task Breakdown

Task breakdown will be generated by `/speckit.tasks` command in next phase.

## Complexity Tracking

**No complexity violations** - This is a straightforward bug fix within existing architecture.

All changes are confined to calculation logic in existing files. No new patterns, abstractions, or architectural changes introduced.

## Next Steps

1. ✅ Complete plan.md (this file)
2. ⏭️ Run `/speckit.tasks` to generate detailed task breakdown
3. ⏭️ Run `/speckit.implement` to execute implementation
4. ⏭️ Run tests and verify fixes
5. ⏭️ Merge to main and deploy
